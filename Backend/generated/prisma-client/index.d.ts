// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  child: (where?: ChildWhereInput) => Promise<boolean>;
  signInOut: (where?: SignInOutWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  child: (where: ChildWhereUniqueInput) => ChildNullablePromise;
  children: (args?: {
    where?: ChildWhereInput;
    orderBy?: ChildOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Child>;
  childrenConnection: (args?: {
    where?: ChildWhereInput;
    orderBy?: ChildOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChildConnectionPromise;
  signInOut: (where: SignInOutWhereUniqueInput) => SignInOutNullablePromise;
  signInOuts: (args?: {
    where?: SignInOutWhereInput;
    orderBy?: SignInOutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SignInOut>;
  signInOutsConnection: (args?: {
    where?: SignInOutWhereInput;
    orderBy?: SignInOutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SignInOutConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createChild: (data: ChildCreateInput) => ChildPromise;
  updateChild: (args: {
    data: ChildUpdateInput;
    where: ChildWhereUniqueInput;
  }) => ChildPromise;
  updateManyChildren: (args: {
    data: ChildUpdateManyMutationInput;
    where?: ChildWhereInput;
  }) => BatchPayloadPromise;
  upsertChild: (args: {
    where: ChildWhereUniqueInput;
    create: ChildCreateInput;
    update: ChildUpdateInput;
  }) => ChildPromise;
  deleteChild: (where: ChildWhereUniqueInput) => ChildPromise;
  deleteManyChildren: (where?: ChildWhereInput) => BatchPayloadPromise;
  createSignInOut: (data: SignInOutCreateInput) => SignInOutPromise;
  updateSignInOut: (args: {
    data: SignInOutUpdateInput;
    where: SignInOutWhereUniqueInput;
  }) => SignInOutPromise;
  updateManySignInOuts: (args: {
    data: SignInOutUpdateManyMutationInput;
    where?: SignInOutWhereInput;
  }) => BatchPayloadPromise;
  upsertSignInOut: (args: {
    where: SignInOutWhereUniqueInput;
    create: SignInOutCreateInput;
    update: SignInOutUpdateInput;
  }) => SignInOutPromise;
  deleteSignInOut: (where: SignInOutWhereUniqueInput) => SignInOutPromise;
  deleteManySignInOuts: (where?: SignInOutWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  child: (
    where?: ChildSubscriptionWhereInput
  ) => ChildSubscriptionPayloadSubscription;
  signInOut: (
    where?: SignInOutSubscriptionWhereInput
  ) => SignInOutSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SignInOutOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "whoSignedIn_ASC"
  | "whoSignedIn_DESC"
  | "whoSignedOut_ASC"
  | "whoSignedOut_DESC"
  | "signInTime_ASC"
  | "signInTime_DESC"
  | "signOutTime_ASC"
  | "signOutTime_DESC"
  | "signInDay_ASC"
  | "signInDay_DESC";

export type ChildOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ChildWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SignInOutWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  whoSignedIn?: Maybe<String>;
  whoSignedIn_not?: Maybe<String>;
  whoSignedIn_in?: Maybe<String[] | String>;
  whoSignedIn_not_in?: Maybe<String[] | String>;
  whoSignedIn_lt?: Maybe<String>;
  whoSignedIn_lte?: Maybe<String>;
  whoSignedIn_gt?: Maybe<String>;
  whoSignedIn_gte?: Maybe<String>;
  whoSignedIn_contains?: Maybe<String>;
  whoSignedIn_not_contains?: Maybe<String>;
  whoSignedIn_starts_with?: Maybe<String>;
  whoSignedIn_not_starts_with?: Maybe<String>;
  whoSignedIn_ends_with?: Maybe<String>;
  whoSignedIn_not_ends_with?: Maybe<String>;
  whoSignedOut?: Maybe<String>;
  whoSignedOut_not?: Maybe<String>;
  whoSignedOut_in?: Maybe<String[] | String>;
  whoSignedOut_not_in?: Maybe<String[] | String>;
  whoSignedOut_lt?: Maybe<String>;
  whoSignedOut_lte?: Maybe<String>;
  whoSignedOut_gt?: Maybe<String>;
  whoSignedOut_gte?: Maybe<String>;
  whoSignedOut_contains?: Maybe<String>;
  whoSignedOut_not_contains?: Maybe<String>;
  whoSignedOut_starts_with?: Maybe<String>;
  whoSignedOut_not_starts_with?: Maybe<String>;
  whoSignedOut_ends_with?: Maybe<String>;
  whoSignedOut_not_ends_with?: Maybe<String>;
  signInTime?: Maybe<String>;
  signInTime_not?: Maybe<String>;
  signInTime_in?: Maybe<String[] | String>;
  signInTime_not_in?: Maybe<String[] | String>;
  signInTime_lt?: Maybe<String>;
  signInTime_lte?: Maybe<String>;
  signInTime_gt?: Maybe<String>;
  signInTime_gte?: Maybe<String>;
  signInTime_contains?: Maybe<String>;
  signInTime_not_contains?: Maybe<String>;
  signInTime_starts_with?: Maybe<String>;
  signInTime_not_starts_with?: Maybe<String>;
  signInTime_ends_with?: Maybe<String>;
  signInTime_not_ends_with?: Maybe<String>;
  signOutTime?: Maybe<String>;
  signOutTime_not?: Maybe<String>;
  signOutTime_in?: Maybe<String[] | String>;
  signOutTime_not_in?: Maybe<String[] | String>;
  signOutTime_lt?: Maybe<String>;
  signOutTime_lte?: Maybe<String>;
  signOutTime_gt?: Maybe<String>;
  signOutTime_gte?: Maybe<String>;
  signOutTime_contains?: Maybe<String>;
  signOutTime_not_contains?: Maybe<String>;
  signOutTime_starts_with?: Maybe<String>;
  signOutTime_not_starts_with?: Maybe<String>;
  signOutTime_ends_with?: Maybe<String>;
  signOutTime_not_ends_with?: Maybe<String>;
  signInDay?: Maybe<String>;
  signInDay_not?: Maybe<String>;
  signInDay_in?: Maybe<String[] | String>;
  signInDay_not_in?: Maybe<String[] | String>;
  signInDay_lt?: Maybe<String>;
  signInDay_lte?: Maybe<String>;
  signInDay_gt?: Maybe<String>;
  signInDay_gte?: Maybe<String>;
  signInDay_contains?: Maybe<String>;
  signInDay_not_contains?: Maybe<String>;
  signInDay_starts_with?: Maybe<String>;
  signInDay_not_starts_with?: Maybe<String>;
  signInDay_ends_with?: Maybe<String>;
  signInDay_not_ends_with?: Maybe<String>;
  child?: Maybe<ChildWhereInput>;
  AND?: Maybe<SignInOutWhereInput[] | SignInOutWhereInput>;
  OR?: Maybe<SignInOutWhereInput[] | SignInOutWhereInput>;
  NOT?: Maybe<SignInOutWhereInput[] | SignInOutWhereInput>;
}

export interface ChildWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  signInOuts_every?: Maybe<SignInOutWhereInput>;
  signInOuts_some?: Maybe<SignInOutWhereInput>;
  signInOuts_none?: Maybe<SignInOutWhereInput>;
  AND?: Maybe<ChildWhereInput[] | ChildWhereInput>;
  OR?: Maybe<ChildWhereInput[] | ChildWhereInput>;
  NOT?: Maybe<ChildWhereInput[] | ChildWhereInput>;
}

export type SignInOutWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ChildCreateInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  signInOuts?: Maybe<SignInOutCreateManyWithoutChildInput>;
}

export interface SignInOutCreateManyWithoutChildInput {
  create?: Maybe<
    SignInOutCreateWithoutChildInput[] | SignInOutCreateWithoutChildInput
  >;
  connect?: Maybe<SignInOutWhereUniqueInput[] | SignInOutWhereUniqueInput>;
}

export interface SignInOutCreateWithoutChildInput {
  id?: Maybe<ID_Input>;
  whoSignedIn: String;
  whoSignedOut?: Maybe<String>;
  signInTime: String;
  signOutTime?: Maybe<String>;
  signInDay: String;
}

export interface ChildUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  signInOuts?: Maybe<SignInOutUpdateManyWithoutChildInput>;
}

export interface SignInOutUpdateManyWithoutChildInput {
  create?: Maybe<
    SignInOutCreateWithoutChildInput[] | SignInOutCreateWithoutChildInput
  >;
  delete?: Maybe<SignInOutWhereUniqueInput[] | SignInOutWhereUniqueInput>;
  connect?: Maybe<SignInOutWhereUniqueInput[] | SignInOutWhereUniqueInput>;
  set?: Maybe<SignInOutWhereUniqueInput[] | SignInOutWhereUniqueInput>;
  disconnect?: Maybe<SignInOutWhereUniqueInput[] | SignInOutWhereUniqueInput>;
  update?: Maybe<
    | SignInOutUpdateWithWhereUniqueWithoutChildInput[]
    | SignInOutUpdateWithWhereUniqueWithoutChildInput
  >;
  upsert?: Maybe<
    | SignInOutUpsertWithWhereUniqueWithoutChildInput[]
    | SignInOutUpsertWithWhereUniqueWithoutChildInput
  >;
  deleteMany?: Maybe<SignInOutScalarWhereInput[] | SignInOutScalarWhereInput>;
  updateMany?: Maybe<
    | SignInOutUpdateManyWithWhereNestedInput[]
    | SignInOutUpdateManyWithWhereNestedInput
  >;
}

export interface SignInOutUpdateWithWhereUniqueWithoutChildInput {
  where: SignInOutWhereUniqueInput;
  data: SignInOutUpdateWithoutChildDataInput;
}

export interface SignInOutUpdateWithoutChildDataInput {
  whoSignedIn?: Maybe<String>;
  whoSignedOut?: Maybe<String>;
  signInTime?: Maybe<String>;
  signOutTime?: Maybe<String>;
  signInDay?: Maybe<String>;
}

export interface SignInOutUpsertWithWhereUniqueWithoutChildInput {
  where: SignInOutWhereUniqueInput;
  update: SignInOutUpdateWithoutChildDataInput;
  create: SignInOutCreateWithoutChildInput;
}

export interface SignInOutScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  whoSignedIn?: Maybe<String>;
  whoSignedIn_not?: Maybe<String>;
  whoSignedIn_in?: Maybe<String[] | String>;
  whoSignedIn_not_in?: Maybe<String[] | String>;
  whoSignedIn_lt?: Maybe<String>;
  whoSignedIn_lte?: Maybe<String>;
  whoSignedIn_gt?: Maybe<String>;
  whoSignedIn_gte?: Maybe<String>;
  whoSignedIn_contains?: Maybe<String>;
  whoSignedIn_not_contains?: Maybe<String>;
  whoSignedIn_starts_with?: Maybe<String>;
  whoSignedIn_not_starts_with?: Maybe<String>;
  whoSignedIn_ends_with?: Maybe<String>;
  whoSignedIn_not_ends_with?: Maybe<String>;
  whoSignedOut?: Maybe<String>;
  whoSignedOut_not?: Maybe<String>;
  whoSignedOut_in?: Maybe<String[] | String>;
  whoSignedOut_not_in?: Maybe<String[] | String>;
  whoSignedOut_lt?: Maybe<String>;
  whoSignedOut_lte?: Maybe<String>;
  whoSignedOut_gt?: Maybe<String>;
  whoSignedOut_gte?: Maybe<String>;
  whoSignedOut_contains?: Maybe<String>;
  whoSignedOut_not_contains?: Maybe<String>;
  whoSignedOut_starts_with?: Maybe<String>;
  whoSignedOut_not_starts_with?: Maybe<String>;
  whoSignedOut_ends_with?: Maybe<String>;
  whoSignedOut_not_ends_with?: Maybe<String>;
  signInTime?: Maybe<String>;
  signInTime_not?: Maybe<String>;
  signInTime_in?: Maybe<String[] | String>;
  signInTime_not_in?: Maybe<String[] | String>;
  signInTime_lt?: Maybe<String>;
  signInTime_lte?: Maybe<String>;
  signInTime_gt?: Maybe<String>;
  signInTime_gte?: Maybe<String>;
  signInTime_contains?: Maybe<String>;
  signInTime_not_contains?: Maybe<String>;
  signInTime_starts_with?: Maybe<String>;
  signInTime_not_starts_with?: Maybe<String>;
  signInTime_ends_with?: Maybe<String>;
  signInTime_not_ends_with?: Maybe<String>;
  signOutTime?: Maybe<String>;
  signOutTime_not?: Maybe<String>;
  signOutTime_in?: Maybe<String[] | String>;
  signOutTime_not_in?: Maybe<String[] | String>;
  signOutTime_lt?: Maybe<String>;
  signOutTime_lte?: Maybe<String>;
  signOutTime_gt?: Maybe<String>;
  signOutTime_gte?: Maybe<String>;
  signOutTime_contains?: Maybe<String>;
  signOutTime_not_contains?: Maybe<String>;
  signOutTime_starts_with?: Maybe<String>;
  signOutTime_not_starts_with?: Maybe<String>;
  signOutTime_ends_with?: Maybe<String>;
  signOutTime_not_ends_with?: Maybe<String>;
  signInDay?: Maybe<String>;
  signInDay_not?: Maybe<String>;
  signInDay_in?: Maybe<String[] | String>;
  signInDay_not_in?: Maybe<String[] | String>;
  signInDay_lt?: Maybe<String>;
  signInDay_lte?: Maybe<String>;
  signInDay_gt?: Maybe<String>;
  signInDay_gte?: Maybe<String>;
  signInDay_contains?: Maybe<String>;
  signInDay_not_contains?: Maybe<String>;
  signInDay_starts_with?: Maybe<String>;
  signInDay_not_starts_with?: Maybe<String>;
  signInDay_ends_with?: Maybe<String>;
  signInDay_not_ends_with?: Maybe<String>;
  AND?: Maybe<SignInOutScalarWhereInput[] | SignInOutScalarWhereInput>;
  OR?: Maybe<SignInOutScalarWhereInput[] | SignInOutScalarWhereInput>;
  NOT?: Maybe<SignInOutScalarWhereInput[] | SignInOutScalarWhereInput>;
}

export interface SignInOutUpdateManyWithWhereNestedInput {
  where: SignInOutScalarWhereInput;
  data: SignInOutUpdateManyDataInput;
}

export interface SignInOutUpdateManyDataInput {
  whoSignedIn?: Maybe<String>;
  whoSignedOut?: Maybe<String>;
  signInTime?: Maybe<String>;
  signOutTime?: Maybe<String>;
  signInDay?: Maybe<String>;
}

export interface ChildUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface SignInOutCreateInput {
  id?: Maybe<ID_Input>;
  whoSignedIn: String;
  whoSignedOut?: Maybe<String>;
  signInTime: String;
  signOutTime?: Maybe<String>;
  signInDay: String;
  child?: Maybe<ChildCreateOneWithoutSignInOutsInput>;
}

export interface ChildCreateOneWithoutSignInOutsInput {
  create?: Maybe<ChildCreateWithoutSignInOutsInput>;
  connect?: Maybe<ChildWhereUniqueInput>;
}

export interface ChildCreateWithoutSignInOutsInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface SignInOutUpdateInput {
  whoSignedIn?: Maybe<String>;
  whoSignedOut?: Maybe<String>;
  signInTime?: Maybe<String>;
  signOutTime?: Maybe<String>;
  signInDay?: Maybe<String>;
  child?: Maybe<ChildUpdateOneWithoutSignInOutsInput>;
}

export interface ChildUpdateOneWithoutSignInOutsInput {
  create?: Maybe<ChildCreateWithoutSignInOutsInput>;
  update?: Maybe<ChildUpdateWithoutSignInOutsDataInput>;
  upsert?: Maybe<ChildUpsertWithoutSignInOutsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChildWhereUniqueInput>;
}

export interface ChildUpdateWithoutSignInOutsDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface ChildUpsertWithoutSignInOutsInput {
  update: ChildUpdateWithoutSignInOutsDataInput;
  create: ChildCreateWithoutSignInOutsInput;
}

export interface SignInOutUpdateManyMutationInput {
  whoSignedIn?: Maybe<String>;
  whoSignedOut?: Maybe<String>;
  signInTime?: Maybe<String>;
  signOutTime?: Maybe<String>;
  signInDay?: Maybe<String>;
}

export interface ChildSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChildWhereInput>;
  AND?: Maybe<ChildSubscriptionWhereInput[] | ChildSubscriptionWhereInput>;
  OR?: Maybe<ChildSubscriptionWhereInput[] | ChildSubscriptionWhereInput>;
  NOT?: Maybe<ChildSubscriptionWhereInput[] | ChildSubscriptionWhereInput>;
}

export interface SignInOutSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SignInOutWhereInput>;
  AND?: Maybe<
    SignInOutSubscriptionWhereInput[] | SignInOutSubscriptionWhereInput
  >;
  OR?: Maybe<
    SignInOutSubscriptionWhereInput[] | SignInOutSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SignInOutSubscriptionWhereInput[] | SignInOutSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Child {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
}

export interface ChildPromise extends Promise<Child>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  signInOuts: <T = FragmentableArray<SignInOut>>(args?: {
    where?: SignInOutWhereInput;
    orderBy?: SignInOutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChildSubscription
  extends Promise<AsyncIterator<Child>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  signInOuts: <T = Promise<AsyncIterator<SignInOutSubscription>>>(args?: {
    where?: SignInOutWhereInput;
    orderBy?: SignInOutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChildNullablePromise
  extends Promise<Child | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  signInOuts: <T = FragmentableArray<SignInOut>>(args?: {
    where?: SignInOutWhereInput;
    orderBy?: SignInOutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SignInOut {
  id: ID_Output;
  whoSignedIn: String;
  whoSignedOut?: String;
  signInTime: String;
  signOutTime?: String;
  signInDay: String;
}

export interface SignInOutPromise extends Promise<SignInOut>, Fragmentable {
  id: () => Promise<ID_Output>;
  whoSignedIn: () => Promise<String>;
  whoSignedOut: () => Promise<String>;
  signInTime: () => Promise<String>;
  signOutTime: () => Promise<String>;
  signInDay: () => Promise<String>;
  child: <T = ChildPromise>() => T;
}

export interface SignInOutSubscription
  extends Promise<AsyncIterator<SignInOut>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  whoSignedIn: () => Promise<AsyncIterator<String>>;
  whoSignedOut: () => Promise<AsyncIterator<String>>;
  signInTime: () => Promise<AsyncIterator<String>>;
  signOutTime: () => Promise<AsyncIterator<String>>;
  signInDay: () => Promise<AsyncIterator<String>>;
  child: <T = ChildSubscription>() => T;
}

export interface SignInOutNullablePromise
  extends Promise<SignInOut | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  whoSignedIn: () => Promise<String>;
  whoSignedOut: () => Promise<String>;
  signInTime: () => Promise<String>;
  signOutTime: () => Promise<String>;
  signInDay: () => Promise<String>;
  child: <T = ChildPromise>() => T;
}

export interface ChildConnection {
  pageInfo: PageInfo;
  edges: ChildEdge[];
}

export interface ChildConnectionPromise
  extends Promise<ChildConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChildEdge>>() => T;
  aggregate: <T = AggregateChildPromise>() => T;
}

export interface ChildConnectionSubscription
  extends Promise<AsyncIterator<ChildConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChildEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChildSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ChildEdge {
  node: Child;
  cursor: String;
}

export interface ChildEdgePromise extends Promise<ChildEdge>, Fragmentable {
  node: <T = ChildPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChildEdgeSubscription
  extends Promise<AsyncIterator<ChildEdge>>,
    Fragmentable {
  node: <T = ChildSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChild {
  count: Int;
}

export interface AggregateChildPromise
  extends Promise<AggregateChild>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChildSubscription
  extends Promise<AsyncIterator<AggregateChild>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SignInOutConnection {
  pageInfo: PageInfo;
  edges: SignInOutEdge[];
}

export interface SignInOutConnectionPromise
  extends Promise<SignInOutConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SignInOutEdge>>() => T;
  aggregate: <T = AggregateSignInOutPromise>() => T;
}

export interface SignInOutConnectionSubscription
  extends Promise<AsyncIterator<SignInOutConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SignInOutEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSignInOutSubscription>() => T;
}

export interface SignInOutEdge {
  node: SignInOut;
  cursor: String;
}

export interface SignInOutEdgePromise
  extends Promise<SignInOutEdge>,
    Fragmentable {
  node: <T = SignInOutPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SignInOutEdgeSubscription
  extends Promise<AsyncIterator<SignInOutEdge>>,
    Fragmentable {
  node: <T = SignInOutSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSignInOut {
  count: Int;
}

export interface AggregateSignInOutPromise
  extends Promise<AggregateSignInOut>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSignInOutSubscription
  extends Promise<AsyncIterator<AggregateSignInOut>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ChildSubscriptionPayload {
  mutation: MutationType;
  node: Child;
  updatedFields: String[];
  previousValues: ChildPreviousValues;
}

export interface ChildSubscriptionPayloadPromise
  extends Promise<ChildSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChildPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChildPreviousValuesPromise>() => T;
}

export interface ChildSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChildSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChildSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChildPreviousValuesSubscription>() => T;
}

export interface ChildPreviousValues {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
}

export interface ChildPreviousValuesPromise
  extends Promise<ChildPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface ChildPreviousValuesSubscription
  extends Promise<AsyncIterator<ChildPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface SignInOutSubscriptionPayload {
  mutation: MutationType;
  node: SignInOut;
  updatedFields: String[];
  previousValues: SignInOutPreviousValues;
}

export interface SignInOutSubscriptionPayloadPromise
  extends Promise<SignInOutSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SignInOutPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SignInOutPreviousValuesPromise>() => T;
}

export interface SignInOutSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SignInOutSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SignInOutSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SignInOutPreviousValuesSubscription>() => T;
}

export interface SignInOutPreviousValues {
  id: ID_Output;
  whoSignedIn: String;
  whoSignedOut?: String;
  signInTime: String;
  signOutTime?: String;
  signInDay: String;
}

export interface SignInOutPreviousValuesPromise
  extends Promise<SignInOutPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  whoSignedIn: () => Promise<String>;
  whoSignedOut: () => Promise<String>;
  signInTime: () => Promise<String>;
  signOutTime: () => Promise<String>;
  signInDay: () => Promise<String>;
}

export interface SignInOutPreviousValuesSubscription
  extends Promise<AsyncIterator<SignInOutPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  whoSignedIn: () => Promise<AsyncIterator<String>>;
  whoSignedOut: () => Promise<AsyncIterator<String>>;
  signInTime: () => Promise<AsyncIterator<String>>;
  signOutTime: () => Promise<AsyncIterator<String>>;
  signInDay: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Child",
    embedded: false
  },
  {
    name: "SignInOut",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
