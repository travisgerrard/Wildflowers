module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateChild {
  count: Int!
}

type AggregateSignInOut {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Child {
  id: ID!
  firstName: String
  lastName: String
  signInOuts(where: SignInOutWhereInput, orderBy: SignInOutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SignInOut!]
}

type ChildConnection {
  pageInfo: PageInfo!
  edges: [ChildEdge]!
  aggregate: AggregateChild!
}

input ChildCreateInput {
  id: ID
  firstName: String
  lastName: String
  signInOuts: SignInOutCreateManyWithoutChildInput
}

input ChildCreateOneWithoutSignInOutsInput {
  create: ChildCreateWithoutSignInOutsInput
  connect: ChildWhereUniqueInput
}

input ChildCreateWithoutSignInOutsInput {
  id: ID
  firstName: String
  lastName: String
}

type ChildEdge {
  node: Child!
  cursor: String!
}

enum ChildOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
}

type ChildPreviousValues {
  id: ID!
  firstName: String
  lastName: String
}

type ChildSubscriptionPayload {
  mutation: MutationType!
  node: Child
  updatedFields: [String!]
  previousValues: ChildPreviousValues
}

input ChildSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChildWhereInput
  AND: [ChildSubscriptionWhereInput!]
  OR: [ChildSubscriptionWhereInput!]
  NOT: [ChildSubscriptionWhereInput!]
}

input ChildUpdateInput {
  firstName: String
  lastName: String
  signInOuts: SignInOutUpdateManyWithoutChildInput
}

input ChildUpdateManyMutationInput {
  firstName: String
  lastName: String
}

input ChildUpdateOneWithoutSignInOutsInput {
  create: ChildCreateWithoutSignInOutsInput
  update: ChildUpdateWithoutSignInOutsDataInput
  upsert: ChildUpsertWithoutSignInOutsInput
  delete: Boolean
  disconnect: Boolean
  connect: ChildWhereUniqueInput
}

input ChildUpdateWithoutSignInOutsDataInput {
  firstName: String
  lastName: String
}

input ChildUpsertWithoutSignInOutsInput {
  update: ChildUpdateWithoutSignInOutsDataInput!
  create: ChildCreateWithoutSignInOutsInput!
}

input ChildWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  signInOuts_every: SignInOutWhereInput
  signInOuts_some: SignInOutWhereInput
  signInOuts_none: SignInOutWhereInput
  AND: [ChildWhereInput!]
  OR: [ChildWhereInput!]
  NOT: [ChildWhereInput!]
}

input ChildWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createChild(data: ChildCreateInput!): Child!
  updateChild(data: ChildUpdateInput!, where: ChildWhereUniqueInput!): Child
  updateManyChildren(data: ChildUpdateManyMutationInput!, where: ChildWhereInput): BatchPayload!
  upsertChild(where: ChildWhereUniqueInput!, create: ChildCreateInput!, update: ChildUpdateInput!): Child!
  deleteChild(where: ChildWhereUniqueInput!): Child
  deleteManyChildren(where: ChildWhereInput): BatchPayload!
  createSignInOut(data: SignInOutCreateInput!): SignInOut!
  updateSignInOut(data: SignInOutUpdateInput!, where: SignInOutWhereUniqueInput!): SignInOut
  updateManySignInOuts(data: SignInOutUpdateManyMutationInput!, where: SignInOutWhereInput): BatchPayload!
  upsertSignInOut(where: SignInOutWhereUniqueInput!, create: SignInOutCreateInput!, update: SignInOutUpdateInput!): SignInOut!
  deleteSignInOut(where: SignInOutWhereUniqueInput!): SignInOut
  deleteManySignInOuts(where: SignInOutWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  child(where: ChildWhereUniqueInput!): Child
  children(where: ChildWhereInput, orderBy: ChildOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Child]!
  childrenConnection(where: ChildWhereInput, orderBy: ChildOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChildConnection!
  signInOut(where: SignInOutWhereUniqueInput!): SignInOut
  signInOuts(where: SignInOutWhereInput, orderBy: SignInOutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SignInOut]!
  signInOutsConnection(where: SignInOutWhereInput, orderBy: SignInOutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SignInOutConnection!
  node(id: ID!): Node
}

type SignInOut {
  id: ID!
  whoSignedIn: String!
  whoSignedOut: String
  signInTime: String!
  signOutTime: String
  signInDay: String!
  child: Child
}

type SignInOutConnection {
  pageInfo: PageInfo!
  edges: [SignInOutEdge]!
  aggregate: AggregateSignInOut!
}

input SignInOutCreateInput {
  id: ID
  whoSignedIn: String!
  whoSignedOut: String
  signInTime: String!
  signOutTime: String
  signInDay: String!
  child: ChildCreateOneWithoutSignInOutsInput
}

input SignInOutCreateManyWithoutChildInput {
  create: [SignInOutCreateWithoutChildInput!]
  connect: [SignInOutWhereUniqueInput!]
}

input SignInOutCreateWithoutChildInput {
  id: ID
  whoSignedIn: String!
  whoSignedOut: String
  signInTime: String!
  signOutTime: String
  signInDay: String!
}

type SignInOutEdge {
  node: SignInOut!
  cursor: String!
}

enum SignInOutOrderByInput {
  id_ASC
  id_DESC
  whoSignedIn_ASC
  whoSignedIn_DESC
  whoSignedOut_ASC
  whoSignedOut_DESC
  signInTime_ASC
  signInTime_DESC
  signOutTime_ASC
  signOutTime_DESC
  signInDay_ASC
  signInDay_DESC
}

type SignInOutPreviousValues {
  id: ID!
  whoSignedIn: String!
  whoSignedOut: String
  signInTime: String!
  signOutTime: String
  signInDay: String!
}

input SignInOutScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  whoSignedIn: String
  whoSignedIn_not: String
  whoSignedIn_in: [String!]
  whoSignedIn_not_in: [String!]
  whoSignedIn_lt: String
  whoSignedIn_lte: String
  whoSignedIn_gt: String
  whoSignedIn_gte: String
  whoSignedIn_contains: String
  whoSignedIn_not_contains: String
  whoSignedIn_starts_with: String
  whoSignedIn_not_starts_with: String
  whoSignedIn_ends_with: String
  whoSignedIn_not_ends_with: String
  whoSignedOut: String
  whoSignedOut_not: String
  whoSignedOut_in: [String!]
  whoSignedOut_not_in: [String!]
  whoSignedOut_lt: String
  whoSignedOut_lte: String
  whoSignedOut_gt: String
  whoSignedOut_gte: String
  whoSignedOut_contains: String
  whoSignedOut_not_contains: String
  whoSignedOut_starts_with: String
  whoSignedOut_not_starts_with: String
  whoSignedOut_ends_with: String
  whoSignedOut_not_ends_with: String
  signInTime: String
  signInTime_not: String
  signInTime_in: [String!]
  signInTime_not_in: [String!]
  signInTime_lt: String
  signInTime_lte: String
  signInTime_gt: String
  signInTime_gte: String
  signInTime_contains: String
  signInTime_not_contains: String
  signInTime_starts_with: String
  signInTime_not_starts_with: String
  signInTime_ends_with: String
  signInTime_not_ends_with: String
  signOutTime: String
  signOutTime_not: String
  signOutTime_in: [String!]
  signOutTime_not_in: [String!]
  signOutTime_lt: String
  signOutTime_lte: String
  signOutTime_gt: String
  signOutTime_gte: String
  signOutTime_contains: String
  signOutTime_not_contains: String
  signOutTime_starts_with: String
  signOutTime_not_starts_with: String
  signOutTime_ends_with: String
  signOutTime_not_ends_with: String
  signInDay: String
  signInDay_not: String
  signInDay_in: [String!]
  signInDay_not_in: [String!]
  signInDay_lt: String
  signInDay_lte: String
  signInDay_gt: String
  signInDay_gte: String
  signInDay_contains: String
  signInDay_not_contains: String
  signInDay_starts_with: String
  signInDay_not_starts_with: String
  signInDay_ends_with: String
  signInDay_not_ends_with: String
  AND: [SignInOutScalarWhereInput!]
  OR: [SignInOutScalarWhereInput!]
  NOT: [SignInOutScalarWhereInput!]
}

type SignInOutSubscriptionPayload {
  mutation: MutationType!
  node: SignInOut
  updatedFields: [String!]
  previousValues: SignInOutPreviousValues
}

input SignInOutSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SignInOutWhereInput
  AND: [SignInOutSubscriptionWhereInput!]
  OR: [SignInOutSubscriptionWhereInput!]
  NOT: [SignInOutSubscriptionWhereInput!]
}

input SignInOutUpdateInput {
  whoSignedIn: String
  whoSignedOut: String
  signInTime: String
  signOutTime: String
  signInDay: String
  child: ChildUpdateOneWithoutSignInOutsInput
}

input SignInOutUpdateManyDataInput {
  whoSignedIn: String
  whoSignedOut: String
  signInTime: String
  signOutTime: String
  signInDay: String
}

input SignInOutUpdateManyMutationInput {
  whoSignedIn: String
  whoSignedOut: String
  signInTime: String
  signOutTime: String
  signInDay: String
}

input SignInOutUpdateManyWithoutChildInput {
  create: [SignInOutCreateWithoutChildInput!]
  delete: [SignInOutWhereUniqueInput!]
  connect: [SignInOutWhereUniqueInput!]
  set: [SignInOutWhereUniqueInput!]
  disconnect: [SignInOutWhereUniqueInput!]
  update: [SignInOutUpdateWithWhereUniqueWithoutChildInput!]
  upsert: [SignInOutUpsertWithWhereUniqueWithoutChildInput!]
  deleteMany: [SignInOutScalarWhereInput!]
  updateMany: [SignInOutUpdateManyWithWhereNestedInput!]
}

input SignInOutUpdateManyWithWhereNestedInput {
  where: SignInOutScalarWhereInput!
  data: SignInOutUpdateManyDataInput!
}

input SignInOutUpdateWithoutChildDataInput {
  whoSignedIn: String
  whoSignedOut: String
  signInTime: String
  signOutTime: String
  signInDay: String
}

input SignInOutUpdateWithWhereUniqueWithoutChildInput {
  where: SignInOutWhereUniqueInput!
  data: SignInOutUpdateWithoutChildDataInput!
}

input SignInOutUpsertWithWhereUniqueWithoutChildInput {
  where: SignInOutWhereUniqueInput!
  update: SignInOutUpdateWithoutChildDataInput!
  create: SignInOutCreateWithoutChildInput!
}

input SignInOutWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  whoSignedIn: String
  whoSignedIn_not: String
  whoSignedIn_in: [String!]
  whoSignedIn_not_in: [String!]
  whoSignedIn_lt: String
  whoSignedIn_lte: String
  whoSignedIn_gt: String
  whoSignedIn_gte: String
  whoSignedIn_contains: String
  whoSignedIn_not_contains: String
  whoSignedIn_starts_with: String
  whoSignedIn_not_starts_with: String
  whoSignedIn_ends_with: String
  whoSignedIn_not_ends_with: String
  whoSignedOut: String
  whoSignedOut_not: String
  whoSignedOut_in: [String!]
  whoSignedOut_not_in: [String!]
  whoSignedOut_lt: String
  whoSignedOut_lte: String
  whoSignedOut_gt: String
  whoSignedOut_gte: String
  whoSignedOut_contains: String
  whoSignedOut_not_contains: String
  whoSignedOut_starts_with: String
  whoSignedOut_not_starts_with: String
  whoSignedOut_ends_with: String
  whoSignedOut_not_ends_with: String
  signInTime: String
  signInTime_not: String
  signInTime_in: [String!]
  signInTime_not_in: [String!]
  signInTime_lt: String
  signInTime_lte: String
  signInTime_gt: String
  signInTime_gte: String
  signInTime_contains: String
  signInTime_not_contains: String
  signInTime_starts_with: String
  signInTime_not_starts_with: String
  signInTime_ends_with: String
  signInTime_not_ends_with: String
  signOutTime: String
  signOutTime_not: String
  signOutTime_in: [String!]
  signOutTime_not_in: [String!]
  signOutTime_lt: String
  signOutTime_lte: String
  signOutTime_gt: String
  signOutTime_gte: String
  signOutTime_contains: String
  signOutTime_not_contains: String
  signOutTime_starts_with: String
  signOutTime_not_starts_with: String
  signOutTime_ends_with: String
  signOutTime_not_ends_with: String
  signInDay: String
  signInDay_not: String
  signInDay_in: [String!]
  signInDay_not_in: [String!]
  signInDay_lt: String
  signInDay_lte: String
  signInDay_gt: String
  signInDay_gte: String
  signInDay_contains: String
  signInDay_not_contains: String
  signInDay_starts_with: String
  signInDay_not_starts_with: String
  signInDay_ends_with: String
  signInDay_not_ends_with: String
  child: ChildWhereInput
  AND: [SignInOutWhereInput!]
  OR: [SignInOutWhereInput!]
  NOT: [SignInOutWhereInput!]
}

input SignInOutWhereUniqueInput {
  id: ID
}

type Subscription {
  child(where: ChildSubscriptionWhereInput): ChildSubscriptionPayload
  signInOut(where: SignInOutSubscriptionWhereInput): SignInOutSubscriptionPayload
}
`
      }
    